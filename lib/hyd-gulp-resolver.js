/**
 * Implements a hydrolysis resolver that passes files through a stream before returning their contents.
 */

// jshint node:true
'use strict';

var fs = require('fs');
var path = require('path');
var url = require('url');
var gulp = require('gulp');
var through2 = require('through2');
var minimatch = require('minimatch');
var gulpDebug = require('gulp-debug');

function getFile(resolver, filePath, deferred,  secondPath) {
	var found = false, rejected = false;
	
	function reject(error) {
		if (rejected) return; // already called
		rejected = true;
		if (secondPath) {
			getFile(resolver, secondPath, deferred);
		} else {
			console.log("Unable to read file", filePath, error);
			deferred.reject(error);
		}
	}
	
	function resolve(file) {
		found = true;
		deferred.resolve(file.contents.toString('utf-8'));
	}
	
	function match(file) {
		return file.relative == filePath || minimatch(file.relative, filePath);
	}
	
	// First, search the extraFiles if any extraneous files match our path
	for (var i = 0; i < resolver.extraFiles.length; i++) {
		if (match(resolver.extraFiles[i])) {
			resolve(resolver.extraFiles[i]);
			// the file was integrated by vulcanize; remove it from the extra files list
			resolver.extraFiles.splice(i, 1);
			return;
		}
	}
	
	// console.log('FINDING', filePath);
	
	// Otherwise, use a gulp stream
	var fileStream = gulp.src(filePath, {
		cwd: resolver.config.includeBase,
		base: resolver.config.includeBase
	});
	if (resolver.config.stream) {
		fileStream = fileStream.pipe(resolver.config.stream());
	}
	fileStream
		.on('data', function(file) {
			// console.log(file.path, file.contents.toString());
			if (match(file)) {
				// console.log('FOUND', file.path, file.contents.toString());
				resolve(file);
			} else {
				// console.log('EXTRA', file.path);
				resolver.extraFiles.push(file);
			}
		})
		.on('error', function(error) {
			reject(error);
		})
		.on('end', function() {
			if (!found) {
				reject('not found');
			}
		});
}

/**
 * Returns true if `patha` is a sibling or aunt of `pathb`.
 * @return {boolean}
 */
function isSiblingOrAunt(patha, pathb) {
	var parent = path.dirname(patha);
	if (pathb.indexOf(patha) === -1 && pathb.indexOf(parent) === 0) {
		return true;
	}
	return false;
}

/**
 * Change `localPath` from a sibling of `basePath` to be a child of
 * `basePath` joined with `redirect`.
 * @return {string}
 */
function redirectSibling(basePath, localPath, redirect) {
	var parent = path.dirname(basePath);
	return path.join(basePath, redirect, localPath.slice(parent.length));
}

/**
 * Resolves requests via Gulp / Vinyl streams, allowing the injection of custom pipes (using callback / lazypipe).
 * 
 * The extraneous files that result in the process can accessed at the end of the vulcanize process using 
 * the `extraFiles` property (which is an Array).
 * 
 * @constructor
 * @memberof hydrolysis
 * @param {Object} config  configuration options.
 * @param {string} config.host Hostname to match for absolute urls.
 *     Matches "/" by default
 * @param {string} config.basePath Prefix directory for components in url.
 *     Defaults to "/".
 * @param {string} config.root Filesystem root to search. Defaults to the
 *     current working directory.
 * @param {string} config.redirect Where to redirect lookups to siblings.
 * @param {string} config.stream A callback function that returns a stream to use for processing included files.
 *                               Hint: you can pass a lazypipe stream.
 */
function FSResolver(config) {
	this.config = config || {};
	this.extraFiles = [];
}

FSResolver.prototype = {
	accept: function (uri, deferred) {
		var parsed = url.parse(uri);
		var host = this.config.host;
		var base = this.config.basePath && decodeURIComponent(this.config.basePath);
		var root = this.config.root && path.normalize(this.config.root);
		var redirect = this.config.redirect;
		
		var local;
		
		if (!parsed.hostname || parsed.hostname === host) {
			local = parsed.pathname;
		}
		if (local) {
			// un-escape HTML escapes
			local = decodeURIComponent(local);
			
			if (base) {
				local = path.relative(base, local);
			}
			if (root) {
				local = path.join(root, local);
			}
			
			var backup;
			if (redirect && isSiblingOrAunt(root, local)) {
				backup = redirectSibling(root, local, redirect);
			}
			
			getFile(this, local, deferred, backup);
			return true;
		}
		
		return false;
	},
	
	/**
	 * Injects the extraneous files generated by the processing streams back into a parent stream.
	 */
	injectExtras: function() {
		var resolver = this;
		return through2.obj(function(file, enc, cb) {
			if (resolver.extraFiles.length) {
				for (var i = 0; i < resolver.extraFiles.length; i++) {
					this.push(resolver.extraFiles[i]);
				}
				resolver.extraFiles = [];
			}
			this.push(file);
			cb();
		});
	}
};

module.exports = FSResolver;
